```
{
	"date": "2021.05.13 09:00",
	"tags": ["camera"],
	"musicId":"109729"
}
```



## 容器基础

容器本质上是一个特殊的进程，容器技术的核心功能就是通过约束和修改进程的动态表现，从而为进程创造一个边界。

对于 Docker 等大多数的 Linux 容器来说，Cgroups 技术是用来制造约束的主要手段，Namespace 技术是用来修改进程视图的方法。

### Namespace

Namespace 技术的功能就是使创建的进程只能看到经过 Namespace 参数所指定的内容（视图），而看不到宿主机以及其他不相关的程序。

（Linux 创建一个新进程的系统调用是 clone()，Namespace 是 clone() 函数创建新进程的一个可选参数。）

需要注意的一点是：Mount Namespace 对容器进程视图的改变，需要伴随这挂载操作 mount 才能生效。为了能够使容器中的进程能够正常运行，需要给进程提供一个完整的操作系统的文件系统，因此容器的根目录是一个完整的操作系统的文件系统。通过 chroot 命令可以修改一个容器（进程）自己看到的根目录视图，(实际上 Mount Namespace 就是在 chroot 的基础上不断改良发明出来的，Mount Namespace 也是 Linux 操作系统里的第一个 Namespace)然后将一个完整的操作系统的文件系统挂载到根目录上面。

这个挂载到容器根目录上，用来为容器进程提供隔离后执行环境的文件系统，就是“容器镜像”。被叫做：rootfs（根文件系统）。

### Cgroups

上面讲解的 Namespace 是容器的隔离技术，而接下来讲解的 Cgroups 是容器的限制技术，这里的限制是指对容器中运行的进程所能拥有的资源进行限制。

Linux Cgroups 就是 Linux 内核中用来为进程设置资源限制的一个重要功能。它最主要的作用就是限制一个进程组能够使用的资源上限（例如 CPU、内存、磁盘、网络带宽等）。

Cgroups 给用户暴露出来的接口是文件系统，Cgroups 以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下。

![image-20210909111214204](/home/lomogo/.config/Typora/typora-user-images/image-20210909111214204.png)

### rootfs 根文件系统

挂载到容器根目录上，用来为容器进程提供隔离后执行环境的文件系统，就是“容器镜像”。被叫做：rootfs（根文件系统）。

rootfs 只是一个操作系统所包含的文件、配置和目录，并不包含操作系统内核。（在 Linux 中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像）

了解了容器的原理之后就可以知道，对于同一台机器上的所有容器，都共享宿主机 Linux 内核。

#### rootfs 的意义

由于 rootfs 应用连同整个操作系统的文件和目录都一起打包了，因此应用以及它运行所需要的所有依赖都被封装到了一起。这就使得容器有了一个重要的特性：一致性，即无论是在本地、云端的任何一台机器上，用户只需要解压打包好的容器镜像，那么这个应用运行所需要的完整的执行环境就被重现出来了。

#### Docker rootfs 的创新

Docker 在镜像的设计中，引入了层（layer）的概念，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。

层的概念可以带来很多好处，如果一个人想要引用别人制作好的一个镜像，那么他就不需要把他新增的修改连同别人的镜像一起打包成一个新的大镜像，而只需将他的相对于别人的镜像**新增的修改打包成一个增量镜像**，这样就可以节省很多的空间。

层的实现利用了联合文件系统：联合文件系统也叫 UnionFS，最主要的功能是将多个不同位置的目录联合挂载（union mount）到同一个目录下，例如：有目录 A 、B，它们分别有两个文件：

```bash
.
├── A
│   ├── a
│   └── x
└── B
    ├── b
    └── x
```

若使用联合挂载的方式将这两个目录挂载到一个公共的目录 C 上后，C 的结构如下：

```bash
➜  C tree       
.
├── a
├── b
└── x

```

在这个合并的目录 C 中，如果对 a b x 文件做修改，这些修改也会在对应的目录 A、B 中生效。

#### Docker 项目是如何使用 UnionFS 的

在 Docker 中有一些版本使用的是 Aufs 这种联合文件系统，对于 Aufs 来说，有几个重要的文件目录：/var/lib/docker/aufs/diff 和 /var/lib/docker/aufs/mnt。镜像的层都放置在 diff 目录下，然后被联合挂载在 mnt 里面。

例如一个 Ubuntu 容器的 rootfs 由三部分组成：

![image-20210909160616352](/home/lomogo/.config/Typora/typora-user-images/image-20210909160616352.png)

**第一部分是只读层**：

这一层对应的正是 ubuntu 镜像的那几层。

**第二部分是可读写层**：

制作镜像时只有可读写层被打包进去。一旦在容器里做了写操作，修改的内容就会以增量的方式出现在读写层中。对于可读写层和只读层，如果两者有相同的文件，那么可读写层的文件就会覆盖掉只读层中的文件。

如果想要修改只读层的内容，首先会从上到下查找有没有这个文件，找到，就复制到容器层（即可读写层）中，修改，修改的结果就会作用到下层的文件，这种方式也被称为 copy-on-write（联合文件系统提供的特性）。

如果想要删除只读层中的内容，例如 foo 文件，那么这个删除操作实际上是在可读写层创建了一个名为 .wh.foo 的文件，当这两个层被联合挂载以后，foo 文件就会被 .wh.foo 文件”遮盖“起来被”删除“了。这就是 ro + wh 的挂载方式即只读 + whiteout 的含义。

**第三部分是 init 层**：

init 层专门用来存放 /etc/hosts、/etc/resolv.conf等信息。例如我们的一些配置往往只能对当前的容器生效，那我们在打包我们的可读写层增量镜像的时候不想把这些配置包含进去，那么这些内容就可以放在 init 层中。

最终，这七个层都被联合挂载到 /var/lib/docker/aufs/mnt 目录下，表现为一个完整的 Ubuntu 操作系统供容器使用。

由于容器镜像的操作是增量式的，这样镜像的大小要小很多。并且由于共享层机制的存在，可以使得所有这些容器镜像需要的总空间也比每个镜像的总和要小。

### Docker 容器核心原理

综上，Docker 容器的核心原理就是为待创建的用户进程提供：

1. 启用 Linux Namespace 配置;
2. 设置指定的 Cgroup 参数;
3. 切换进程的根目录（Change Root）。

这样，一个完整的 Docker 容器就创建完成了。

所以知道了 Docker 容器的核心原理之后就可以知道，Mac OS 和 Windows 平台的 Docker 其实是 Docker for Win/Mac 自身先借助虚拟化技术创造了一个 Linux 虚拟机之后再在这个 Linux 虚拟机的基础上创造 Linux 容器。

### 其他进程如何进入到一个容器中

当一个容器正在运行的时候可以通过`docker exec`命令进入到这个正在运行的容器中，那么`docker exec`是如何进入到容器里面的呢？

首先容器所能看到的视图是经过 Namespace 指定之后的视图，那如果其他进程能够获取加入到这个容器的 Namespace 中，那么这个进程能看到的视图就和该容器一致，这样其实也就达到了该进程进入到容器里的目的。事实上，`docker exec`进入到容器里面的原理就是这样。

一个进程创建的 Namespace 信息以文件的方式存在于宿主机上。可以通过以下命令获取到一个正在运行的 Docker 容器的进程号 PID：

```bash
docker inspect --format '{{ .State.Pid }}' [容器id]
```

利用这个进程的 PID 通过如下命令可以在宿主机上看到该进程的所有 Namespace 对应的文件：

```bash
ls -l /proc/2743/ns
```

有了这些文件之后就意味着，一个进程，可以选择加入到某个进程已有的 Namespace 当中，从而达到“进入”这个进程所在容器的目的，这正是`docker exec`的实现原理。

而进程加入已有的 Namespace 的操作可以依赖 sents() 的 Linux 系统调用方法实现。加入后，该进程和容器进程共享 Namespace 文件。

### 容器如何读取和修改宿主机上的内容

通过 Docker 的 Volume 机制，可以实现将宿主机上指定的目录或文件，挂载到容器里面进行读取和修改操作。它的实现原理是这样的：容器在被创建了之后，尽管启用了 Mount Namespace，但是在它执行 chroot 操作修改根目录之前，这个容器是可以看到宿主机上的整个文件系统的。因此只需要在执行 chroot 操作之前，将宿主上的指定目录挂载到容器的可读写层里面就可以实现 Volume 机制了。

虽然这个容器上宿主机文件的挂载点是处于只读层的，但是当打包一个镜像的时候并不会将宿主机上被挂载的文件打包进去，这是因为容器上的挂载目录的指针指向的是被挂载的目录中的文件对象，在容器中修改的也只是宿主机上被挂载的文件对象，而容器中的挂载点目录里的文件对象并没有被修改，因此在打包镜像的时候虽然这个挂载点目录也被打包了，但是这个目录里面的内容为空。

### 容器与虚拟机

![image-20210908153501539](/home/lomogo/.config/Typora/typora-user-images/image-20210908153501539.png)

上图的左边是虚拟机的工作原理。Hypervisor 这个软件是虚拟机最重要的部分。它通过硬件虚拟化功能，模拟出了运行一个操作系统需要的各种硬件。这样用户的进程就可以运行在这个虚拟的机器里，这个进程看到的只有 Guest OS 的文件和目录以及这个机器里的虚拟设备。这样，各个虚拟机也就起到了将不同的应用程序相互隔离的作用。

### 容器相比虚拟机的优点：敏捷、高性能

上图的右边是容器的工作原理。宿主机的操作系统通过 Namespace 技术将各个容器隔离起来。因此用户运行在容器里的应用程序跟宿主机上的其他进程一样，这种虚拟化带来的性能损耗是不存在的。并且使用 Namespace 作为隔离手段的容器不像虚拟机那样必须使用单独的 Guest OS，这使得容器额外消耗的资源占用几乎可以忽略不及。

### 容器的缺点

- 基于 Linux Namespace 的隔离机制相比于虚拟化技术最主要的问题就是隔离的不够彻底。
  - 多个容器之间使用的是同一个宿主机的操作系统内核。
  - Linux 内核中有一些资源和对象是不能被 Namespace 化的，例如时间。
- Cgroups 对资源的限制能力不足，比如 /proc 文件系统：/proc 目录下存储的是记录当前内核运行状态的一系列特殊文件，比如进程的信息、cpu 使用情况、内存占用等。如果在容器里面执行 top 指令，会发现其显示的信息是宿主机的 CPU 和内存数据，而不是当前容器的数据。主要原因是 /proc 文件系统不了解 Cgroups 限制的存在。

